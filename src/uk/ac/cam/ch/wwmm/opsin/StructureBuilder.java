package uk.ac.cam.ch.wwmm.opsin;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.Stack;

import uk.ac.cam.ch.wwmm.ptclib.io.ResourceGetter;
import uk.ac.cam.ch.wwmm.ptclib.xml.XOMTools;

import nu.xom.Document;
import nu.xom.Element;
import nu.xom.Elements;
import nu.xom.Nodes;

/**Constructs the CML molecule from the postprocessor results.
 *
 * @author ptc24/dl387
 *
 */
class StructureBuilder {

	private static ResourceGetter resourceGetter = NameToStructure.resourceGetter;
	/** A builder for fragments specified as SSMILES */
	SSMILESFragmentBuilder ssBuilder;
	/** A builder for fragments specified as references to a CML data file */
	CMLFragmentBuilder cmlBuilder;
	/** The Word Rule that was assigned to this molecule*/
	private String wordRule;
	/** Holds the state of the molecule that is under construction*/
	private BuildState state;

	/*Holds the rules on how suffixes are interpreted.*/
	Document suffixRulesDoc;

	/**Initialises.
	 *
	 * @throws Exception If the suffixRules won't load, or the fragManager won't initialise.
	 */
	StructureBuilder() throws Exception {
		suffixRulesDoc = resourceGetter.getXMLDocument("suffixRules.xml");
		ssBuilder = new SSMILESFragmentBuilder();
		cmlBuilder = new CMLFragmentBuilder();
	}

	/**Builds a CML molecule based on the preStructurebuilder output.
	 *
	 * @param molecule The preStructurebuilder output.
	 * @param state Holds the idManager and fragmentManager for the partially assembled molecule generated by the preStructurebuilder
	 * @return A cml element, containing a molecule element.
	 * @throws StructureBuildingException If the molecule won't build - there may be many reasons.
	 */
	Element buildCML(Element molecule, BuildState state) throws StructureBuildingException {
		this.state =state;
		Fragment f = buildFragment(molecule);
		return f.toCMLMolecule();
	}

	/**	Builds a molecule as a Fragment based on preStructurebuilder output.
	 *
	 * @param molecule The preStructurebuilderr output.
	 * @return A single Fragment - the built molecule.
	 * @throws StructureBuildingException If the molecule won't build - there may be many reasons.
	 */
	Fragment buildFragment(Element molecule) throws StructureBuildingException {
		wordRule = molecule.getAttributeValue("wordRule");
		Elements words = molecule.getChildElements();
		BuildResults moleculeBuildResults;//contains every atom in the molecule. If a mixture was the input then both "molecules" will be in this
		if(wordRule.equals("ester") || wordRule.equals("diester")) { //e.g. ethyl ethanoate, dimethyl terephthalate,  methyl propanamide
			moleculeBuildResults =resolveWordOrBracket(words.get(0), null, new LinkedHashSet<Fragment>());
			int substituentCount=1;
			int i = 1;
			while(words.get(i).getAttributeValue("type").equals("substituent")) {
				moleculeBuildResults.mergeBuildResults(resolveWordOrBracket(words.get(i), null, new LinkedHashSet<Fragment>()));
				substituentCount++;
				i++;
			}
			while(i <words.size() && words.get(i).getAttributeValue("type").equals("full")) {
				moleculeBuildResults.mergeBuildResults(resolveWordOrBracket(words.get(i), null, new LinkedHashSet<Fragment>()));
				i++;
			}

			int esterIdCount = moleculeBuildResults.functionalIDs.size();
			int esterBondsToForm =Math.min(moleculeBuildResults.functionalIDs.size(), moleculeBuildResults.getOutIDCount());

			if (substituentCount > esterIdCount){
				throw new StructureBuildingException("Name appears to have erroneous spaces interfering with ester interpretation");
			}

			if (esterIdCount !=moleculeBuildResults.getOutIDCount() ){//could mean there are radicals or unused esters
				//special case for diester being used as monoesters
				if (esterIdCount ==  moleculeBuildResults.getOutIDCount() *2  && (words.size() -substituentCount) * 2 == esterIdCount){
					for(i=esterIdCount -1; i>=0 ;i--) {
						if (i % 2 ==1){
							moleculeBuildResults.functionalIDs.remove(i);
						}
					}
				}
			}

			for(i=0;i<esterBondsToForm;i++) {
				Atom ateAtom =moleculeBuildResults.getFunctionalOutAtom(0);
				moleculeBuildResults.functionalIDs.remove(0);
				state.fragManager.attachFragments(ateAtom,moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(0), 1);
				moleculeBuildResults.removeOutID(0);
				ateAtom.setCharge(0);
			}
		}
		else if (wordRule.equals("functionalClassEster")){//e.g. ethanoic acid ethyl ester
			if (words.size()!=4){
				throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
			}
			moleculeBuildResults =resolveWordOrBracket(words.get(0), null, new LinkedHashSet<Fragment>());//the group
			moleculeBuildResults.mergeBuildResults(resolveWordOrBracket(words.get(2), null, new LinkedHashSet<Fragment>()));
			if (moleculeBuildResults.functionalIDs.size()!=1 || moleculeBuildResults.getOutIDCount() !=1){
				throw new StructureBuildingException("Name appears to be ambiguous: functionalIDs: " + moleculeBuildResults.functionalIDs.size() + " outIDs: " +moleculeBuildResults.getOutIDCount());
			}
			Atom functionalAtom =moleculeBuildResults.getFunctionalOutAtom(0);
			state.fragManager.attachFragments(functionalAtom,moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(0), 1);
			functionalAtom.setCharge(0);
			moleculeBuildResults.removeAllOutIDs();
		}
		else if (wordRule.equals("monovalentFunctionalGroup")){// ethyl chloride or isophthaloyl dichloride
			BuildResults substituentBR =resolveWordOrBracket(words.get(0), null, new LinkedHashSet<Fragment>());
			moleculeBuildResults =substituentBR;
			for (int i = 0; i < substituentBR.getOutIDCount(); i++) {//replaces outIDs with valency greater than 1 with multiple outIDs; e.g. ylidene -->diyl
				OutID outID =substituentBR.getOutID(i);
				if (outID.valency>1){
					for (int j = 2; j <= outID.valency; j++) {
						substituentBR.addOutID(outID.id, 1, outID.setExplicitly);
					}
					outID.valency=1;
				}
			}
			int numberOfOutIDs =substituentBR.getOutIDCount();
			if (numberOfOutIDs > words.size()-1){//something like isophthaloyl chloride (more precisely written isophthaloyl dichloride)
				if (words.size()-1 != 1){
					throw new StructureBuildingException("Incorrect number of functional class groups found to balance outIDs");
				}
				int diff =numberOfOutIDs - (words.size()-1);
				Element elementToBeCloned =words.get(words.size()-1);
				for (int i = 0; i < diff; i++) {
					Element clone =state.fragManager.cloneElement(elementToBeCloned, state);
					XOMTools.insertAfter(elementToBeCloned, clone);
					elementToBeCloned=clone;
				}
				words = molecule.getChildElements();
			}
			for (int i = 1; i <= numberOfOutIDs; i++) {
				BuildResults ideBR =resolveWordOrBracket(words.get(i), null, new LinkedHashSet<Fragment>());
				moleculeBuildResults.mergeBuildResults(ideBR);
				Atom ideAtom =ideBR.getMainFragment().getAtomByIDOrThrow(ideBR.getMainFragment().getDefaultInID());
				Atom subAtom=substituentBR.getOutAtomTakingIntoAccountWhetherSetExplicitly(0);
				state.fragManager.attachFragments(ideAtom, subAtom, 1);
				substituentBR.removeOutID(0);
				ideAtom.setCharge(0);
			}

			for (int i = numberOfOutIDs +1; i <words.size(); i++) {//resolve anything else
				moleculeBuildResults.mergeBuildResults(resolveWordOrBracket(words.get(i), null, new LinkedHashSet<Fragment>()));
			}
		}
		else if(wordRule.equals("monovalentLiteralFunctionalGroup")) {
			if (words.size()!=2){
				throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
			}
			String smilesOfGroup = null;
			String functionalGroupName =words.get(1).getValue();
			if (functionalGroupName.equalsIgnoreCase("alcohol")){
				smilesOfGroup="O";
			}
			else if (functionalGroupName.equalsIgnoreCase("selenol")){
				smilesOfGroup="[Se]";
			}
			else if (functionalGroupName.equalsIgnoreCase("thiol")){
				smilesOfGroup="S";
			}
			else{
				throw new StructureBuildingException("Unknown functionalGroup: " + functionalGroupName);
			}
			moleculeBuildResults =resolveWordOrBracket(words.get(0), null, new LinkedHashSet<Fragment>());//the group
			for (int i = 0; i < moleculeBuildResults.getOutIDCount(); i++) {
				Atom outAtom =moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(i);
				Fragment rGroup =state.fragManager.buildSMILES(smilesOfGroup);
				if (moleculeBuildResults.getOutID(i).valency !=1){
					throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + moleculeBuildResults.getOutID(i).valency);
				}
				state.fragManager.attachFragments(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), 1);
			}
			moleculeBuildResults.removeAllOutIDs();
		}
		else if(wordRule.equals("divalentLiteralFunctionalGroup")) {
			String smilesOfGroup = null;
			String functionalGroupName =words.get(words.size()-1).getValue();
			if (functionalGroupName.equalsIgnoreCase("ether")){
				smilesOfGroup="O";
			}
			else if (functionalGroupName.equalsIgnoreCase("ketone")){
				smilesOfGroup="C=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("peroxide")){
				smilesOfGroup="OO-";
			}
			else if (functionalGroupName.equalsIgnoreCase("selenide")){
				smilesOfGroup="[Se]";
			}
			else if (functionalGroupName.equalsIgnoreCase("selenone")){
				smilesOfGroup="[Se](=O)=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("selenoxide")){
				smilesOfGroup="[Se]=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("selone")){
				smilesOfGroup="C=[Se]";
			}
			else if (functionalGroupName.equalsIgnoreCase("selenoketone")){
				smilesOfGroup="[Se]=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("sulfide")){
				smilesOfGroup="S";
			}
			else if (functionalGroupName.equalsIgnoreCase("sulfone")){
				smilesOfGroup="S(=O)=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("sulfoxide")){
				smilesOfGroup="S=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("telluride")){
				smilesOfGroup="[Te]";
			}
			else if (functionalGroupName.equalsIgnoreCase("telluroketone")){
				smilesOfGroup="[Te]=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("tellurone")){
				smilesOfGroup="[Te](=O)=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("telluroxide")){
				smilesOfGroup="[Te]=O";
			}
			else if (functionalGroupName.equalsIgnoreCase("thioketone")){
				smilesOfGroup="S=O";
			}
			else{
				throw new StructureBuildingException("Unknown functionalGroup: " + functionalGroupName);
			}

			Fragment rGroup =state.fragManager.buildSMILES(smilesOfGroup,"simpleGroup", "functionalGroup", "none");
			if (words.size()!=2 && words.size()!=3){
				throw new StructureBuildingException("Unexpected number of words. Expected 2 or 3, found: " + words.size());
			}

			if (words.size()==2){//e.g. methyl sulfoxide rather than dimethyl sulfoxide
				Element clone = state.fragManager.cloneElement(words.get(0), state);
				XOMTools.insertAfter(words.get(0), clone);
				words = molecule.getChildElements();
			}

			moleculeBuildResults =resolveWordOrBracket(words.get(0), null, new LinkedHashSet<Fragment>());
			if (moleculeBuildResults.getOutIDCount()!=1){
				throw new StructureBuildingException("Excpected one out outID. Found " + moleculeBuildResults.getOutIDCount() );
			}
			if (moleculeBuildResults.getOutID(0).valency !=1){
				throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + moleculeBuildResults.getOutID(0).valency);
			}
			Atom outAtom =moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(0);
			moleculeBuildResults.removeOutID(0);
			if (rGroup.getOutIDs().size()==1){//c.f. peroxide where it is a linker
				state.fragManager.attachFragments(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getOutID(0).id), 1);
				rGroup.removeOutID(0);
			}
			else{
				state.fragManager.attachFragments(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), 1);
			}

			moleculeBuildResults.mergeBuildResults(resolveWordOrBracket(words.get(1), null, new LinkedHashSet<Fragment>()));
			if (moleculeBuildResults.getOutIDCount()!=1){
				throw new StructureBuildingException("Excpected one out outID. Found " + moleculeBuildResults.getOutIDCount() );
			}
			if (moleculeBuildResults.getOutID(0).valency !=1){
				throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + moleculeBuildResults.getOutID(0).valency);
			}
			outAtom =moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(0);
			moleculeBuildResults.removeOutID(0);
			state.fragManager.attachFragments(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), 1);
		}
		else if(wordRule.equals("glycol")) {
			if (words.size()!=2){
				throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
			}
			moleculeBuildResults =resolveWordOrBracket(words.get(0), null, new LinkedHashSet<Fragment>());//the group
			if (moleculeBuildResults.getOutIDCount()!=2){
				throw new StructureBuildingException("Glycol class names (e.g. ethylene glycol) expect two outIDs. Found: " + moleculeBuildResults.getOutIDCount() );
			}
			for (int i = 0; i < moleculeBuildResults.getOutIDCount(); i++) {
				Atom outAtom =moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(i);
				Fragment glycol =state.fragManager.buildSMILES("O");
				if (moleculeBuildResults.getOutID(i).valency !=1){
					throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + moleculeBuildResults.getOutID(i).valency);
				}
				state.fragManager.attachFragments(outAtom, glycol.getAtomByIDOrThrow(glycol.getIdOfFirstAtom()), 1);
			}
			moleculeBuildResults.removeAllOutIDs();
		}
//		else if (wordRule.equals("oxime")){//e.g. Imidazole-2-carboxamide O-ethyloxime, pentan-3-one oxime
//			int substituentPresent;
//			if (words.size()==2){
//				substituentPresent=0;
//			}
//			else if (words.size()==3){
//				substituentPresent=1;
//			}
//			else{
//				throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
//			}
//			
//			int numberOfOximes =1;
//			moleculeBuildResults =resolveWordOrBracket(words.get(0), null, new LinkedHashSet<Fragment>());//the group
//			List<List<Atom>> matches = moleculeBuildResults.subStructureSearch("O=C", state.fragManager);
//			System.out.println(matches.size());
//			if (matches.size() < numberOfOximes){
//				throw new StructureBuildingException("Insufficient carbonyl groups found!");
//			}
//
//			for (int i = 0; i < numberOfOximes; i++) {
//				List<Atom> atomList = matches.get(i);
//				Atom atomToBeReplaced =atomList.get(0);//the oxygen of the carbonyl
//				Fragment parentFrag =atomToBeReplaced.getFrag();
//				atomToBeReplaced.setElement("N");
//				int ID = state.idManager.getNextID();
//				List<Atom> parentFragAtomList =parentFrag.getAtomList();
//				for (Atom atom :parentFragAtomList) {
//					if (atom.hasLocant("O")){
//						atom.removeLocant("O");
//					}
//				}
//				Atom addedHydroxy = new Atom(ID, "O", "O", parentFrag);
//				parentFrag.addAtom(addedHydroxy);
//				Bond newBond =new Bond(atomToBeReplaced.getID(), addedHydroxy.getID(), 1);
//				parentFrag.addBond(newBond);
//				if (i== 0 && substituentPresent==1){
//					moleculeBuildResults.mergeBuildResults(resolveWordOrBracket(words.get(1), null, new LinkedHashSet<Fragment>()));
//					if (moleculeBuildResults.getOutIDCount() !=1){
//						throw new StructureBuildingException("Expected outID on substituent before oxime");
//					}
//					state.fragManager.attachFragments(addedHydroxy, moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(0), moleculeBuildResults.getOutID(0).valency);
//					moleculeBuildResults.removeOutID(0);
//				}
//			}
//		}
		else if(wordRule.equals("binaryOrOther")) {
			moleculeBuildResults=resolveWordOrBracket(words.get(words.size()-1), null, new LinkedHashSet<Fragment>());
			for (int i = words.size()-2; i >=0; i--) {//allows resolving of counter ions first
				moleculeBuildResults.mergeBuildResults(resolveWordOrBracket(words.get(i), null, new LinkedHashSet<Fragment>()));
			}
		}else if(wordRule.equals("simple") || wordRule.equals("acid")) {
			Element word = molecule.getFirstChildElement("word");
			if(word == null) throw new StructureBuildingException("Molecule contains no words!?");
			moleculeBuildResults =resolveWordOrBracket(word, null, new LinkedHashSet<Fragment>());
		}
		else{
			throw new StructureBuildingException("Unknown Word Rule");
		}
		state.fragManager.tidyUpFragments();
		state.fragManager.convertSpareValenciesToDoubleBonds();

		//adds Xe group at all atoms which have unused outIDs
		//note that SMILES generated by CDK is not always correct
//		for (int i = 0; i < moleculeBuildResults.getOutIDCount(); i++) {
//			Atom outAtom =moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(i);
//			Fragment rGroup =state.fragManager.buildSMILES("[Xe]");
//			state.fragManager.attachFragments(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), moleculeBuildResults.getOutID(i).valency);
//		}
		state.fragManager.checkValencies();
		Fragment uniFrag = state.fragManager.getUnifiedFrags();
		return uniFrag;
	}

	/**Resolves the contents of a &lt;word&gt; or &lt;bracket&gt; tag, recursively.
	 *
	 * @param wob The &lt;word&gt; or &lt;bracket&gt; tag.
	 * @param parentFrag The fragment that the results are to be attached to. May be null.
	 * @param fragmentsToAvoid Usually empty list of fragments that should not be joined to their parentFrag
	 * @return A buildResults for the results of building.
	 * @throws StructureBuildingException If the contents won't build properly.
	 */
	BuildResults resolveWordOrBracket(Element wob, Fragment parentFrag, LinkedHashSet<Fragment> fragmentsToAvoid) throws StructureBuildingException {
		if (parentFrag==null && wob.getLocalName().equals("word")){
			if (state.firstMultiRadical.get(wob) !=null){
				ArrayList<Element> elements =new ArrayList<Element>();
				Element root =state.firstMultiRadical.get(wob);
				state.firstMultiRadical.remove(wob);
				elements.add(root);
				BuildResults buildResults = resolveRootOrSubstituent(root, null, new Nodes(), fragmentsToAvoid);
				BuildResults buildResultsMultiplicative = resolveWordOrBracketLeftToRight(buildResults, elements);
				buildResultsMultiplicative.mergeBuildResults(resolveWordOrBracket(wob, null, buildResultsMultiplicative.fragments));

				Nodes groups =XQueryUtil.xquery(wob, ".//group");
				for (int i = 0; i < groups.size(); i++) {
					if (!buildResults.fragments.contains(state.xmlFragmentMap.get(groups.get(i)))){
						throw new StructureBuildingException("OPSIN's multiplicative nomenclature implementation has failed to resolve all groups!");
					}
				}
				return buildResultsMultiplicative;
			}
		}
		String locantStr = "0";

		if(wob.getAttribute("locant")!= null) {
			locantStr = wob.getAttributeValue("locant");
		}
		Element root = wob.getFirstChildElement("root");
		Nodes bracketsOrSubs = XQueryUtil.xquery(wob, "./bracket|./substituent");
		BuildResults buildResults = null;
		if(root == null) {
			Element lastBracketOrSub =(Element)bracketsOrSubs.get(bracketsOrSubs.size()-1);
			if (lastBracketOrSub.getLocalName().equals("bracket")){
				//if this is a bracket things get complicated as we need to have resolved everything in this recursively,
				//starting from the last deepest bracket. The criteria of being the last element takes priority over depth
				while (lastBracketOrSub.getLocalName().equals("bracket")){
					bracketsOrSubs = XQueryUtil.xquery(lastBracketOrSub, "./bracket|./substituent|./root");
					lastBracketOrSub =(Element)bracketsOrSubs.get(bracketsOrSubs.size()-1);
				}
				root =lastBracketOrSub;
				buildResults = resolveRootOrSubstituent(lastBracketOrSub, null, new Nodes(), fragmentsToAvoid );
				do {
					lastBracketOrSub =(Element) lastBracketOrSub.getParent();
					bracketsOrSubs = XQueryUtil.xquery(lastBracketOrSub, "./bracket|./substituent|./root");
					for (int i = bracketsOrSubs.size() -2; i >=0; i--) {//don't use last element as that's the root
						Element currentChild= (Element)bracketsOrSubs.get(i);
						if (currentChild.getLocalName().equals("bracket")){
							buildResults.mergeBuildResults(resolveWordOrBracket(currentChild, buildResults.getMainFragment(), fragmentsToAvoid));
						}
						else{
							buildResults.mergeBuildResults(resolveRootOrSubstituent(currentChild , buildResults.getMainFragment(), new Nodes(), fragmentsToAvoid));
						}
					}
				} while(!lastBracketOrSub.equals(wob));
			}
			else{
				root =lastBracketOrSub;
			}
		}
		if (buildResults==null){
			buildResults = resolveRootOrSubstituent(root, null, bracketsOrSubs, fragmentsToAvoid);
			Nodes roots= XQueryUtil.xquery(wob, "./root");
			for (int i = 1; i < roots.size(); i++) {//special case where there are multiple roots e.g. naphthalene-1,5-diyl 4,4'-bis(2,5-dioxo-1H-pyrrol-1-yl)dibenzoate (this is not technically multiplicative)
				buildResults.mergeBuildResults(resolveRootOrSubstituent((Element) roots.get(i), null, new Nodes(), fragmentsToAvoid));
			}
		}

		if(parentFrag != null && !fragmentsToAvoid.contains(buildResults.getMainFragment())) {
			joinFragments(buildResults, (Element) root.getParent(), parentFrag, locantStr);
		}
		return buildResults;
	}


	/**Resolves the contents of a &lt;word&gt; or &lt;bracket&gt; tag, recursively BUT from left to right
	 * This is utilised by multiplicative nomenclature
	 *
	 * @param root The substituent containing the multiradical that starts the multiplicative nomenclature e.g. ethylene in ethylenedinitrilotetraacetic acid
	 * @param parentFrag The fragment that the results are to be attached to. May be null.
	 * @return A buildResults for the results of building.
	 * @throws StructureBuildingException If the contents won't build properly.
	 */
	private BuildResults resolveWordOrBracketLeftToRight(BuildResults buildResults, ArrayList<Element> roots) throws StructureBuildingException {
		ArrayList<Element> elementsUsed =new ArrayList<Element>();
		int numberOfOutIDs =buildResults.getOutIDCount();
		if (numberOfOutIDs <=1){//no longer multiplicative nomenclature (should be the end of the name...)
			if (numberOfOutIDs==1){
				for (Element root : roots) {//I think if this code is run something has gone wrong!
					Element group=root.getFirstChildElement("group");
					if (group!=null){
						buildResults.fragments.remove(state.xmlFragmentMap.get(group));
					}
				}
			}
			return buildResults;
		}

		int outIDsPerRoot =numberOfOutIDs/roots.size();
//		System.out.println("number of roots: " + roots.size());
//		System.out.println("outIdsPerRoot " + outIDsPerRoot);
		int extraOutIDs = numberOfOutIDs % roots.size();//if this is not 0 then the resulting structure will be a radical
		if (extraOutIDs!=0){
			throw new StructureBuildingException("Unhandled use of multiplicative nomenclature");
		}

		//resolve left to right
		mainLoop: for (int i = 0; i < roots.size(); i++) {
			Element root =roots.get(i);
			int outIDsForThisRoot =outIDsPerRoot;
			//System.out.println("Root " + i);
			Element parent =(Element) root.getParent();

			int indexOfRoot =parent.indexOf(root);
			Elements children =parent.getChildElements();
			ArrayList<Element> potentialSubsAndRoots =new ArrayList<Element>();
			for (int j = 0; j < children.size(); j++) {
				Element currentElement =(Element)children.get(j);
				if (j > indexOfRoot && (currentElement.getLocalName().equals("substituent") || currentElement.getLocalName().equals("bracket") || currentElement.getLocalName().equals("root"))
						&& !roots.contains(currentElement) && !elementsUsed.contains(currentElement)){
					
					if (currentElement.getLocalName().equals("bracket")){
						if (currentElement.getAttribute("type")==null){//don't want to explore implicit brackets
							Element foundEl =getFirstUnusedSubOrRootFromBracket(currentElement, roots, elementsUsed);
							if (foundEl!=null){
								potentialSubsAndRoots.add(foundEl);
							}
						}
					}
					else{
						Element group =currentElement.getFirstChildElement("group");
						if (group.getAttribute("isAMultiRadical")!=null || state.xmlFragmentMap.get(group).getOutIDs().size()==0){//you want either a linker or a terminal. e.g. oxy, nitrilo etc. or a ender e.g. phenol, benzene, ethanol.
							potentialSubsAndRoots.add(currentElement);
						}
					}
				}
			}
			if (potentialSubsAndRoots.size() ==0){break;}

//			System.out.println(root.toXML());
//			System.out.println("number of available options: " + potentialSubsAndRoots.size());


			//TODO Do this properly e.g. only do it in specific cases e.g. methylenecyclohexane, not methandiylcyclohexane
//			int bondOrder =outIDsPerRoot/potentialBracketsOrSubs.size();
//			if (potentialBracketsOrSubs.size() < outIDsForThisRoot){//some of the outID need to be removed and others have their valency increased
//				if (outIDsPerRoot % potentialBracketsOrSubs.size() !=0){
//					throw new StructureBuildingException("Unhandled use of multiplicative nomenclature");
//				}
//				int valencyCount=0;//how much valency has been changed
//				ArrayList<OutID> outIDsToRemove =new ArrayList<OutID>();
//				for (OutID outId : buildResults.outIDs) {
//					if (valencyCount>0 && outId.valency==1){
//						outIDsToRemove.add(outId);
//						valencyCount--;
//					}
//					if (outId.valency<bondOrder){
//						valencyCount= valencyCount+(bondOrder-outId.valency);
//						outId.valency=bondOrder;
//					}
//				}
//				buildResults.outIDs.removeAll(outIDsToRemove);
//			}

			for (int j = 0; j < potentialSubsAndRoots.size(); j++) {
				Element currentSubOrRoot =(Element)potentialSubsAndRoots.get(j);
				if (outIDsForThisRoot >=1){
					//System.out.println("current: " + currentSubOrRoot.toXML());
					if(!buildResults.fragments.contains(state.xmlFragmentMap.get(currentSubOrRoot.getFirstChildElement("group")))){
						BuildResults tempChildBuildResults = resolveRootOrSubstituent(currentSubOrRoot , null, new Nodes(), new LinkedHashSet<Fragment>());
						joinFragmentsMultiplicative(tempChildBuildResults, buildResults);
						buildResults.mergeBuildResults(tempChildBuildResults);
						elementsUsed.add(currentSubOrRoot);
						outIDsForThisRoot--;
					}
				}
				else{
					continue mainLoop;
				}
			}
		}
		if (elementsUsed.size()!=0){
			return resolveWordOrBracketLeftToRight(buildResults, elementsUsed);
		}

		if (numberOfOutIDs !=0 && roots.size() >0){
			for (int i = 0; i < roots.size(); i++) {
				Element parent =(Element) roots.get(i).getParent();
				if (parent.getLocalName().equals("bracket")){
					roots.set(i, parent);
				}
				else{
					return buildResults;
					//as it isn't in a bracket all of the molecule should have been evaluated, so the only conclusion is that the molecule is a radical
				}
			}
			return resolveWordOrBracketLeftToRight(buildResults, roots);
		}
		return buildResults;
	}

	/**
	 * Finds the first acceptable sub or root child of the element given (which is a bracket). Any brackets that are encountered are recursively enumerated
	 * @param currentElement The bracket from which to search the children of
	 * @param roots Used to check whether the element is unacceptable
	 * @param elementsUsed Used to check whether the element is unacceptable
	 * @return element The element found or null
	 * @throws StructureBuildingException 
	 */
	private Element getFirstUnusedSubOrRootFromBracket(Element currentElement, ArrayList<Element> roots, ArrayList<Element> elementsUsed) throws StructureBuildingException {
		Elements bracketChildren =currentElement.getChildElements();
		if (bracketChildren.size() > 0){
			for (int i = 0; i < bracketChildren.size(); i++) {
				Element bracketChild =(Element) bracketChildren.get(i);
				if (bracketChild.getLocalName().equals("substituent") || bracketChild.getLocalName().equals("bracket") || bracketChild.getLocalName().equals("root")){
					if (bracketChild.getLocalName().equals("bracket") ){
						if (bracketChild.getAttribute("type")==null){
							Element foundEl = getFirstUnusedSubOrRootFromBracket(bracketChild, roots, elementsUsed);
							if (foundEl!=null){
								return foundEl;
							}
						}
					}
					else{
						if (!roots.contains(currentElement) && !elementsUsed.contains(currentElement)){
							Element group =bracketChild.getFirstChildElement("group");
							if (group.getAttribute("isAMultiRadical")!=null || state.xmlFragmentMap.get(group).getOutIDs().size()==0){//you want either a linker or a terminal. e.g. oxy, nitrilo etc. or a ender e.g. phenol, benzene, ethanol.
								return bracketChild;
							}
						}
					}
				}
			}
			return null;
		}
		else{
			throw new StructureBuildingException("Empty bracket!");
		}
	}
	

	/**Resolves the contents of a &lt;root&gt; or &lt;substituent&gt; tag.
	 *
	 * @param rootOrSub The &lt;root&gt; or &lt;substituent&gt; tag.
	 * @param parentFrag The fragment to which the built fragment will be attached. May be null.
	 * @param bracketsOrSubsNodes The nodes which should be evaluated and connected to the fragment built from rootOrSub. Can be empty
	 * @param fragmentsToAvoid Usually empty list of fragments that should not be joined to their parentFrag
	 * @return A buildResults for the results of building.
	 * @throws StructureBuildingException If the contents won't build properly.
	 */
	BuildResults resolveRootOrSubstituent(Element rootOrSub, Fragment parentFrag, Nodes bracketsOrSubsNodes, LinkedHashSet<Fragment> fragmentsToAvoid) throws StructureBuildingException {
		Element group = rootOrSub.getFirstChildElement("group");
		Fragment thisFrag = state.xmlFragmentMap.get(group);

		ArrayList<Element> unsaturators = new ArrayList<Element>();
		ArrayList<Element> heteroatoms = new ArrayList<Element>();
		ArrayList<Element> stereoChemistry = new ArrayList<Element>();
		ArrayList<Element> hydrogenElements = new ArrayList<Element>();
		ArrayList<Element> bracketsOrSubs = OpsinTools.nodesToElementArrayList(bracketsOrSubsNodes);

		Elements children =rootOrSub.getChildElements();
		for (int i = 0; i < children.size(); i++) {
			Element currentEl =children.get(i);
			String elName =currentEl.getLocalName();
			if (elName.equals("unsaturator")){
				unsaturators.add(currentEl);
			}
			else if (elName.equals("heteroatom")){
				heteroatoms.add(currentEl);
			}
			else if (elName.equals("stereoChemistry")){
				stereoChemistry.add(currentEl);
			}
			else if (elName.equals("hydro")){
				hydrogenElements.add(currentEl);
			}
			else if (elName.equals("hydrogen")){
				hydrogenElements.add(currentEl);
			}
			else if (elName.equals("indicatedHydrogen")){
				hydrogenElements.add(currentEl);
			}
		}

		/*
		 *OutID queries from this point onwards should be directed to the buildResults
		 */
		BuildResults buildResults = new BuildResults(thisFrag);
		if (fragmentsToAvoid.contains(buildResults.getMainFragment())){
			buildResults.functionalIDs.clear();
			buildResults.removeAllOutIDs();
		}

		int idOfFirstAtomInFragment= thisFrag.getIdOfFirstAtom();
		//used if locants are not specified; whenever used it is incremented
		//all non-suffix atoms in the fragment are eventually checked if the defaultId does not correspond to a suitable atom
		//e.g. if the id was 3 in a 5 atom fragment which had ids 1-5, atoms would be checked for suitability in the order 3,4,5,1,2
		int defaultId = idOfFirstAtomInFragment;

		/*
		 * Add locanted functionality
		 */
		for(int i=hydrogenElements.size() -1;i >= 0;i--) {
			Element hydrogen = hydrogenElements.get(i);
			String locant = getLocant(hydrogen);
			if(!locant.equals("0")) {
				thisFrag.getAtomByLocantOrThrow(locant).subtractSpareValency(1);
				hydrogenElements.remove(hydrogen);
			}
			hydrogen.detach();
		}

		for(int i=unsaturators.size() -1;i >= 0;i--) {
			Element unsaturator = unsaturators.get(i);
			String locant = getLocant(unsaturator);
			int bondOrder = Integer.parseInt(unsaturator.getAttributeValue("value"));
			if(bondOrder <= 1) {
				continue;
			}
			if(!locant.equals("0")){
				unsaturators.remove(unsaturator);
				Integer idOfFirstAtomInMultipleBond=thisFrag.getIDFromLocantOrThrow(locant);
				if (unsaturator.getAttribute("compoundLocant")!=null){
					state.fragManager.unsaturate(idOfFirstAtomInMultipleBond, unsaturator.getAttributeValue("compoundLocant"), bondOrder, thisFrag);
				}
				else{
					state.fragManager.unsaturate(idOfFirstAtomInMultipleBond, bondOrder, thisFrag);
				}
			}
			unsaturator.detach();
		}

		for(int i=heteroatoms.size() -1;i >= 0;i--) {
			Element heteroatom = heteroatoms.get(i);
			String locant = getLocant(heteroatom);
			String atomSSMILES = heteroatom.getAttributeValue("value");
			if(!locant.equals("0")) {
				state.fragManager.makeHeteroatom(thisFrag.getAtomByLocantOrThrow(locant), atomSSMILES, thisFrag);
				heteroatoms.remove(heteroatom);
			}
			heteroatom.detach();
		}

		for(int j=0;j<stereoChemistry.size();j++) {
			Element stereoChemistryElement = stereoChemistry.get(j);
			if (stereoChemistryElement.getAttributeValue("type").equals("RorS")){
				String locant = getLocant(stereoChemistryElement);
				String rOrS = stereoChemistryElement.getAttributeValue("value");
				if(parentFrag != null) {
					Atom a = parentFrag.getAtomByLocant(locant);
					if (a !=null){
						a.setStereochemistry(rOrS);
					}
				}
				else{
					Atom a = thisFrag.getAtomByLocant(locant);
					if (a !=null){
						a.setStereochemistry(rOrS);
					}
				}
			}
			else{
				//currently unsupported
			}
			stereoChemistryElement.detach();
		}

		for(int i=bracketsOrSubs.size() -1;i >= 0;i--) {
			Element bracketOrSub = (Element)bracketsOrSubs.get(i);
			if (bracketOrSub.equals(rootOrSub)){continue;}
			if(bracketOrSub.getAttribute("locant") != null) {
				//slim possibility does exist that the locant is not referring to this fragment
				if (thisFrag.getAtomByLocant(bracketOrSub.getAttributeValue("locant"))!=null){
					if (bracketOrSub.getLocalName().equals("bracket")){
						buildResults.mergeBuildResults(resolveWordOrBracket(bracketOrSub, thisFrag, fragmentsToAvoid));
					}
					else{
						buildResults.mergeBuildResults(resolveRootOrSubstituent(bracketOrSub , thisFrag, new Nodes(), fragmentsToAvoid));
					}
					bracketsOrSubs.remove(i);
				}
			}
		}

		if(parentFrag != null) {
			/* attach the Fragment that has just been built to the parentFrag */
			if(!fragmentsToAvoid.contains(buildResults.getMainFragment()) && rootOrSub.getAttribute("locant") != null) {
				String locantStr =rootOrSub.getAttributeValue("locant");
				joinFragments(buildResults, rootOrSub, parentFrag, locantStr);
			}
		}

		/*
		 * Add unlocanted functionality
		 */

		for(int j=0;j<hydrogenElements.size();j++) {
			//finds an atom that can accept a hydrogen
			Atom atomToReduceSpareValencyOn=thisFrag.getAtomByIDOrThrow(defaultId);
			atomToReduceSpareValencyOn.ensureSVIsConsistantWithValency(false);
			while (atomToReduceSpareValencyOn.getSpareValency() <=0 ){
				defaultId++;
				atomToReduceSpareValencyOn=thisFrag.getAtomByIDOrThrow(defaultId);
				if (atomToReduceSpareValencyOn.getType().equals("suffix")){
					throw new StructureBuildingException("No suitable atom found");
				}
				atomToReduceSpareValencyOn.ensureSVIsConsistantWithValency(false);
			}
			atomToReduceSpareValencyOn.subtractSpareValency(1);
			defaultId++;
			hydrogenElements.get(j).detach();
		}
		defaultId = idOfFirstAtomInFragment;

		for(int j=0;j<unsaturators.size();j++) {
			Element unsaturator = unsaturators.get(j);
			int bondOrder = Integer.parseInt(unsaturator.getAttributeValue("value"));
			if(bondOrder <= 1) {
				continue;
			}
			//checks if both atoms can accept an extra bond (if double bond) or two extra bonds (if triple bond)

			Atom currentAtom =thisFrag.getAtomByIDOrThrow(defaultId);
			Atom nextAtom =thisFrag.getAtomByIDOrThrow(defaultId +1);
			while (currentAtom.getSpareValency() != 0 || ValencyChecker.checkValencyAvailableForBond(currentAtom, bondOrder-1) != true ||
					nextAtom.getSpareValency() != 0 || ValencyChecker.checkValencyAvailableForBond(nextAtom, bondOrder-1) != true){
				defaultId++;
				currentAtom =thisFrag.getAtomByIDOrThrow(defaultId);
				nextAtom =thisFrag.getAtomByIDOrThrow(defaultId +1);
				if (currentAtom.getType().equals("suffix") || nextAtom.getType().equals("suffix")){
					throw new StructureBuildingException("No suitable atom found");
				}
			}
			Integer idOfFirstAtomInMultipleBond=currentAtom.getID();
			if (unsaturator.getAttribute("compoundLocant")!=null){
				state.fragManager.unsaturate(idOfFirstAtomInMultipleBond, unsaturator.getAttributeValue("compoundLocant"), bondOrder, thisFrag);
			}
			else{
				state.fragManager.unsaturate(idOfFirstAtomInMultipleBond, bondOrder, thisFrag);
			}
			defaultId=idOfFirstAtomInMultipleBond +2;
			unsaturator.detach();
		}
		defaultId = idOfFirstAtomInFragment;

		for(int j=0;j<heteroatoms.size();j++) {
			Element heteroatom = heteroatoms.get(j);
			String atomSSMILES = heteroatom.getAttributeValue("value");
			//finds an atom for which changing it to the specified heteroatom will not cause valency to be violated
			Atom atomToReplaceWithHeteroAtom=thisFrag.getAtomByIDOrThrow(defaultId);
			while (ValencyChecker.checkValencyAvailableForReplacementByHeteroatom(atomToReplaceWithHeteroAtom, atomSSMILES) != true){
				defaultId++;
				atomToReplaceWithHeteroAtom=thisFrag.getAtomByIDOrThrow(defaultId);
				if (atomToReplaceWithHeteroAtom.getType().equals("suffix")){
					throw new StructureBuildingException("No suitable atom found");
				}
			}
			state.fragManager.makeHeteroatom(atomToReplaceWithHeteroAtom, atomSSMILES, thisFrag);
			defaultId++;
			heteroatom.detach();
		}
		defaultId = idOfFirstAtomInFragment;

		for(int i=bracketsOrSubs.size() -1;i >= 0;i--) {
			Element bracketOrSub = (Element)bracketsOrSubs.get(i);
			if (bracketOrSub.equals(rootOrSub)){continue;}
			if (bracketOrSub.getLocalName().equals("bracket")){
				buildResults.mergeBuildResults(resolveWordOrBracket(bracketOrSub, thisFrag, fragmentsToAvoid));
			}
			else{
				buildResults.mergeBuildResults(resolveRootOrSubstituent(bracketOrSub , thisFrag, new Nodes(), fragmentsToAvoid));
			}
		}

		if(parentFrag != null) {
			/* attach the Fragment that has just been built to the parentFrag */
			if(!fragmentsToAvoid.contains(buildResults.getMainFragment()) && rootOrSub.getAttribute("locant") == null) {
				joinFragments(buildResults, rootOrSub, parentFrag, "0");
			}
		}

		return buildResults;
	}

	/**
	 * Used to join two fragments. If the locant is not present on the parent alternative feasible fragments will be accessed to
	 * try to find a fragment with a suitable locant which assumedly was the fragment to which bonding was intended
	 * @param fragToBeJoinedBuildResults: BuildResults for the fragment to be joined
	 * @param parentSubstituentOrBracketOfFrag: The XML corresponding to the substituent/bracket this fragment is in
	 * This is a bracket if called from resolveWordOrBracket or a substituent if called from resolveRootOrSubstituent
	 * @param parentFrag: The parent fragment to attach to
	 * @param locantStr: A locant on this fragment
	 * @throws StructureBuildingException
	 */
	private void joinFragments(BuildResults fragToBeJoinedBuildResults, Element parentSubstituentOrBracketOfFrag,
			Fragment parentFrag, String locantStr) throws StructureBuildingException {

		Fragment fragToBeJoined =fragToBeJoinedBuildResults.getMainFragment();
		if (fragToBeJoinedBuildResults.getOutIDCount() <=0){
			throw new StructureBuildingException("Fragment does not have any specified outIDs!");
		}
		Atom from =fragToBeJoinedBuildResults.getOutAtom(0);
		int bondOrder =fragToBeJoinedBuildResults.getFirstOutID().valency;
		if (fragToBeJoinedBuildResults.getFirstOutID().setExplicitly != true){//not set explicitly so may be an inappropriate atom
			from=fragToBeJoined.getAtomByIdOrNextSuitableAtomOrThrow(from.getID(), bondOrder);
		}
		fragToBeJoinedBuildResults.removeOutID(0);

		Atom to =null;
		if(locantStr.equals("0")){
			to = parentFrag.getAtomByIdOrNextSuitableAtom(parentFrag.getDefaultInID(), bondOrder, true);
		}
		else{
			to =parentFrag.getAtomByLocant(locantStr);
		}

		//case where you should actually be substituting onto the previous element e.g. 5-(4-methylphenylcarbonyl)pentane
		if (to==null){
			if(locantStr.equals("0")){
				ArrayList<Fragment> possibleParents =findAlternativeFragments(parentSubstituentOrBracketOfFrag);
				for (Fragment fragment : possibleParents) {
					to = fragment.getAtomByIdOrNextSuitableAtom(fragment.getDefaultInID(), bondOrder, true);
					if (to !=null){
						break;
					}
				}
				if (to  ==null){
					throw new StructureBuildingException("Cannot find fragment to reasonably attach atom with id: " +from.getID() +" to using unspecified locant");
				}
			}
			else{
				parentFrag =findAlternativeFragmentWithLocant(parentSubstituentOrBracketOfFrag, locantStr);
				if (parentFrag  ==null){
					throw new StructureBuildingException("Cannot find fragment to reasonably attach atom with id: " +from.getID() +" to using locant: " + locantStr);
				}
				to =parentFrag.getAtomByLocant(locantStr);
			}
		}
		state.fragManager.attachFragments(from, to, bondOrder);
	}

	/**
	 * Joins two fragments together. The main difference between this and joinFragments is that this function expects no specified locants
	 * and that in this on the parentBuildResult loses an OutID, not the fragment to be joined.
	 * @param fragToBeJoinedBuildResults
	 * @param parentFragBuildResults
	 * @throws StructureBuildingException
	 */
	private void joinFragmentsMultiplicative(BuildResults fragToBeJoinedBuildResults, BuildResults parentFragBuildResults) throws StructureBuildingException {
		Fragment fragToBeJoined =fragToBeJoinedBuildResults.getMainFragment();
		if (parentFragBuildResults.getOutIDCount() <=0){
			throw new StructureBuildingException("Fragment does not have any specified outIDs!");
		}
		Atom from =parentFragBuildResults.getOutAtom(0);
		int bondOrder =parentFragBuildResults.getFirstOutID().valency;
		if (parentFragBuildResults.getFirstOutID().setExplicitly != true){//not set explicitly so may be an inappropriate atom
			from=from.getFrag().getAtomByIdOrNextSuitableAtomOrThrow(from.getID(), bondOrder);
		}
		parentFragBuildResults.removeOutID(0);

		Atom to = fragToBeJoined.getAtomByIdOrNextSuitableAtomOrThrow(fragToBeJoined.getDefaultInID(), bondOrder);
		state.fragManager.attachFragments(from, to, bondOrder);
	}

	/**
	 * Checks through the groups accessible from the currentElement taking into account brackets
	 * i.e. those that it is feasible that the group of the currentElement could substitute onto
	 * @param currentElement
	 * @param locant: the locant string to check for the presence of
	 * @return The fragment with the locant, or null
	 */
	private Fragment findAlternativeFragmentWithLocant(Element startingElement, String locant) {
		Stack<Element> s = new Stack<Element>();
		s.add(startingElement);
		
		boolean doneFirstIteration =false;//check on index only done on first iteration to only get elements with an index greater than the starting element
		while (s.size()>0){
			Element currentElement =s.pop();
			if (currentElement.getLocalName().equals("group")){
				Fragment groupFrag =state.xmlFragmentMap.get(currentElement);
				if (groupFrag.hasLocant(locant)){
					return groupFrag;
				}
				continue;
			}
			Element parent = (Element)currentElement.getParent();
			Nodes siblings = XQueryUtil.xquery(parent, "./bracket|./substituent|./root");

			for (int i =0; i<siblings.size(); i++) {
				Element bracketOrSub = (Element)siblings.get(i);
				if (!doneFirstIteration && parent.indexOf(bracketOrSub )<=parent.indexOf(currentElement)){
					continue;
				}
				if (bracketOrSub.getLocalName().equals("bracket")){
					s.push((Element)bracketOrSub.getChild(0));
				}
				else{
					Element group = bracketOrSub.getFirstChildElement("group");
					s.push(group);
				}
			}
			doneFirstIteration =true;
		}
		return null;
	}
	
	/**
	 * Finds all the groups accessible from the currentElement taking into account brackets
	 * i.e. those that it is feasible that the group of the currentElement could substitute onto
	 * @param currentElement
	 * @return A list of fragments in the order to try them as possible parent fragments
	 */
	private ArrayList<Fragment> findAlternativeFragments(Element startingElement) {
		Stack<Element> s = new Stack<Element>();
		s.add(startingElement);
		ArrayList<Fragment> foundFragments =new ArrayList<Fragment>();
		boolean doneFirstIteration =false;//check on index only done on first iteration to only get elements with an index greater than the starting element
		while (s.size()>0){
			Element currentElement =s.pop();
			if (currentElement.getLocalName().equals("group")){
				Fragment groupFrag =state.xmlFragmentMap.get(currentElement);
				foundFragments.add(groupFrag);
				continue;
			}
			Element parent = (Element)currentElement.getParent();
			Nodes siblings = XQueryUtil.xquery(parent, "./bracket|./substituent|./root");

			for (int i =0; i<siblings.size(); i++) {
				Element bracketOrSub = (Element)siblings.get(i);
				if (!doneFirstIteration && parent.indexOf(bracketOrSub )<=parent.indexOf(currentElement)){
					continue;
				}
				if (bracketOrSub.getLocalName().equals("bracket")){
					s.push((Element)bracketOrSub.getChild(0));
				}
				else{
					Element group = bracketOrSub.getFirstChildElement("group");
					s.push(group);
				}
			}
			doneFirstIteration =true;
		}
		return foundFragments;
	}


	/**Gets the locant from a group/suffix tag, defaulting to "0"
	 *
	 * @param element
	 * @return The locant on the group/suffix tag.
	 */
	static String getLocant(Element element) {
		String locantStr = element.getAttributeValue("locant");
		if(locantStr == null) return "0";
		return locantStr;
	}

	void setState(BuildState state) {
		this.state =state;
	}
}
